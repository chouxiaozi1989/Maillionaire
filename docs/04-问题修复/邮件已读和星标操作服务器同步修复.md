# 邮件已读和星标操作服务器同步修复

## 问题描述

用户反馈邮件已读操作没有同步到服务器，Gmail 账户应该使用 API 操作。

经过检查发现，邮件已读和星标操作存在以下问题：
1. `markAsRead()` 函数只更新本地状态，未同步服务器
2. `toggleFlag()` 函数只更新本地状态，未同步服务器
3. 虽然 `markAsReadOnServer()` 和 `toggleFlagOnServer()` 已经正确实现，但 UI 层调用的是不带 `OnServer` 后缀的版本

## 问题分析

### 原有实现（有问题）

#### markAsRead 函数（第 547-550 行）
```javascript
/**
 * 标记为已读/未读
 */
async function markAsRead(mailId, read = true) {
  await updateMail(mailId, { read })  // ❌ 只更新本地状态
}
```

#### toggleFlag 函数（第 552-558 行）
```javascript
/**
 * 切换星标
 */
async function toggleFlag(mailId) {
  const mail = mails.value.find(m => m.id === mailId)
  if (mail) {
    await updateMail(mailId, { flagged: !mail.flagged })  // ❌ 只更新本地状态
  }
}
```

### UI 层调用情况

在多个组件中发现调用了不带服务器同步的版本：

#### Inbox.vue（第 149 行）
```javascript
function handleMailClick(mail) {
  showDetailModal.value = true
  
  // 标记为已读
  if (!mail.read) {
    mailStore.markAsRead(mail.id)  // ❌ 未同步服务器
  }
}

async function handleToggleStar(mail) {
  try {
    await mailStore.toggleFlag(mail.id)  // ❌ 未同步服务器
    message.success(mail.flagged ? '已取消星标' : '已加星标')
  } catch (error) {
    message.error('操作失败：' + error.message)
  }
}
```

#### Sent.vue（第 89 行）
```javascript
function handleMailClick(mail) {
  selectedMail.value = mail
  showDetailModal.value = true
  mailStore.markAsRead(mail.id)  // ❌ 未同步服务器
}
```

### 正确的服务器同步实现

实际上，`markAsReadOnServer()` 和 `toggleFlagOnServer()` 已经正确实现了服务器同步：

#### markAsReadOnServer（第 1082-1141 行）
```javascript
async function markAsReadOnServer(mailId, read = true) {
  try {
    const account = accountStore.currentAccount
    const mail = mails.value.find(m => m.id === mailId)
    
    const isGmail = account.provider === 'gmail' || 
                    account.imapHost?.includes('gmail.com') ||
                    account.email?.endsWith('@gmail.com')

    if (isGmail && account.oauth2 && account.accessToken && mail.gmailId) {
      // ✅ 使用 Gmail API 标记
      const accessToken = await ensureValidToken(account, accountStore)
      const { gmailApiService } = await import('@/services/gmail-api')
      
      if (read) {
        await gmailApiService.markAsRead(accessToken, mail.gmailId)
      } else {
        await gmailApiService.markAsUnread(accessToken, mail.gmailId)
      }
    } else if (window.electronAPI && mail.uid) {
      // ✅ 使用 IMAP 标记
      await window.electronAPI.connectImap({...})
      await window.electronAPI.markImapMailAsRead(mail.uid)
      await window.electronAPI.disconnectImap()
    }
    
    // 更新本地状态
    await updateMail(mailId, { read })
  } catch (error) {
    console.error('[Mail] Failed to mark mail:', error)
    throw error
  }
}
```

#### toggleFlagOnServer（第 1148-1204 行）
```javascript
async function toggleFlagOnServer(mailId) {
  try {
    const mail = mails.value.find(m => m.id === mailId)
    const account = accountStore.currentAccount
    const newFlaggedState = !mail.flagged

    const isGmail = account.provider === 'gmail' || 
                    account.imapHost?.includes('gmail.com') ||
                    account.email?.endsWith('@gmail.com')

    if (isGmail && account.oauth2 && account.accessToken && mail.gmailId) {
      // ✅ 使用 Gmail API 操作星标
      const accessToken = await ensureValidToken(account, accountStore)
      const { gmailApiService } = await import('@/services/gmail-api')
      
      if (newFlaggedState) {
        await gmailApiService.addStar(accessToken, mail.gmailId)
      } else {
        await gmailApiService.removeStar(accessToken, mail.gmailId)
      }
    }
    
    // 更新本地状态
    await updateMail(mailId, { flagged: newFlaggedState })
  } catch (error) {
    console.error('[Mail] Failed to toggle flag:', error)
    throw error
  }
}
```

## 解决方案

修复 `markAsRead()` 和 `toggleFlag()` 函数，让它们调用带服务器同步的版本，类似于 `deleteMail()` 的修复方式。

### 修复后的实现

#### markAsRead 函数
```javascript
/**
 * 标记为已读/未读（同步到服务器）
 */
async function markAsRead(mailId, read = true) {
  try {
    await markAsReadOnServer(mailId, read)  // ✅ 调用服务器同步版本
  } catch (error) {
    console.error('[Mail] Failed to mark as read:', error)
    throw error
  }
}
```

#### toggleFlag 函数
```javascript
/**
 * 切换星标（同步到服务器）
 */
async function toggleFlag(mailId) {
  try {
    await toggleFlagOnServer(mailId)  // ✅ 调用服务器同步版本
  } catch (error) {
    console.error('[Mail] Failed to toggle flag:', error)
    throw error
  }
}
```

## 修改内容

### 修改文件：`src/stores/mail.js`

**第 544-558 行**
```javascript
/**
 * 标记为已读/未读（同步到服务器）
 */
async function markAsRead(mailId, read = true) {
  try {
    await markAsReadOnServer(mailId, read)
  } catch (error) {
    console.error('[Mail] Failed to mark as read:', error)
    throw error
  }
}

/**
 * 切换星标（同步到服务器）
 */
async function toggleFlag(mailId) {
  try {
    await toggleFlagOnServer(mailId)
  } catch (error) {
    console.error('[Mail] Failed to toggle flag:', error)
    throw error
  }
}
```

## 修复效果

### 修复前
1. **标记已读**：只更新本地状态 `{ read: true }`
2. **切换星标**：只更新本地状态 `{ flagged: !mail.flagged }`
3. **问题**：服务器邮件状态不变，刷新后丢失本地修改

### 修复后
1. **标记已读**：
   - Gmail 账户：调用 `gmailApiService.markAsRead()` 或 `markAsUnread()`
   - IMAP 账户：调用 `window.electronAPI.markImapMailAsRead()`
   - 更新本地状态

2. **切换星标**：
   - Gmail 账户：调用 `gmailApiService.addStar()` 或 `removeStar()`
   - 更新本地状态

3. **效果**：服务器和本地状态保持一致，刷新后数据不丢失

## Gmail API 使用情况

修复后，所有邮件操作都正确使用 Gmail API：

### markAsRead / markAsUnread
```javascript
// src/services/gmail-api.js
async markAsRead(accessToken, messageId) {
  return await this.modifyMessage(accessToken, messageId, {
    removeLabelIds: ['UNREAD'],
  })
}

async markAsUnread(accessToken, messageId) {
  return await this.modifyMessage(accessToken, messageId, {
    addLabelIds: ['UNREAD'],
  })
}
```

### addStar / removeStar
```javascript
// src/services/gmail-api.js
async addStar(accessToken, messageId) {
  return await this.modifyMessage(accessToken, messageId, {
    addLabelIds: ['STARRED'],
  })
}

async removeStar(accessToken, messageId) {
  return await this.modifyMessage(accessToken, messageId, {
    removeLabelIds: ['STARRED'],
  })
}
```

## 统一的修复模式

这次修复遵循了与邮件删除操作相同的模式：

### 模式对比

#### 删除操作（已修复）
```javascript
// 用户调用的方法
async function deleteMail(mailId) {
  await deleteMailFromServer(mailId)  // 调用服务器同步版本
}

// 服务器同步实现
async function deleteMailFromServer(mailId) {
  // Gmail API 或 IMAP 删除
  // 更新本地状态
}
```

#### 已读操作（本次修复）
```javascript
// 用户调用的方法
async function markAsRead(mailId, read) {
  await markAsReadOnServer(mailId, read)  // 调用服务器同步版本
}

// 服务器同步实现
async function markAsReadOnServer(mailId, read) {
  // Gmail API 或 IMAP 标记
  // 更新本地状态
}
```

#### 星标操作（本次修复）
```javascript
// 用户调用的方法
async function toggleFlag(mailId) {
  await toggleFlagOnServer(mailId)  // 调用服务器同步版本
}

// 服务器同步实现
async function toggleFlagOnServer(mailId) {
  // Gmail API 操作星标
  // 更新本地状态
}
```

### 统一规则

1. **UI 层**：调用简单的方法名（如 `markAsRead`、`toggleFlag`、`deleteMail`）
2. **简单方法**：立即调用带 `OnServer` 后缀的版本
3. **`OnServer` 方法**：
   - 检测账户类型（Gmail 或 IMAP）
   - Gmail 账户：使用 Gmail API
   - IMAP 账户：使用 IMAP 协议
   - 更新本地状态
   - 保存数据

## 测试建议

1. **测试标记已读**：
   - 点击邮件后自动标记为已读
   - 检查服务器邮件状态是否更新
   - 刷新应用，验证已读状态是否保持

2. **测试切换星标**：
   - 点击星标图标
   - 检查服务器邮件是否添加/移除 STARRED 标签
   - 刷新应用，验证星标状态是否保持

3. **测试 Gmail API**：
   - 使用 Gmail 账户测试
   - 在 Gmail 网页版中验证更改是否同步
   - 检查是否使用了正确的 API endpoint

4. **测试 IMAP 账户**：
   - 使用非 Gmail 账户（如 Outlook、QQ 邮箱）测试
   - 验证 IMAP 标记命令是否正确执行

## 相关文档

- [邮件删除服务器同步修复](./邮件删除服务器同步修复.md) - 使用相同的修复模式
- [Gmail API 集成文档](../03-功能实现/Gmail-API-集成.md) - Gmail API 使用规范
- [IMAP 协议集成](../03-功能实现/IMAP-协议集成.md) - IMAP 操作方法

## 总结

通过修复 `markAsRead()` 和 `toggleFlag()` 函数，确保了：
1. ✅ 所有邮件操作都同步到服务器
2. ✅ Gmail 账户使用 API 操作
3. ✅ IMAP 账户使用协议操作
4. ✅ 本地和服务器数据保持一致
5. ✅ 遵循统一的修复模式

这与之前的邮件删除修复保持了一致的架构和实现方式。
