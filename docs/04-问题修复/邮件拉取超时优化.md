# 邮件拉取超时优化

**日期**: 2025-10-22  
**问题**: 拉取邮件时长时间无反应  
**状态**: ✅ 已修复

## 问题描述

用户在同步邮件时遇到以下问题：
- 点击"同步"按钮后，长时间处于加载状态
- 控制台没有错误信息，但也没有成功提示
- 用户无法知道是否在处理中还是已经卡死
- 大量邮件拉取时容易超时

## 根本原因分析

### 1. 缺少超时机制
**文件**: `electron/services/imap-main.js`

[fetchAndParseMails](file://c:\Users\Administrator\Documents\Maillionaire\electron\services\imap-main.js#L595-L661) 方法没有设置超时：
- IMAP fetch 操作可能因网络问题无限等待
- 没有超时保护，导致整个应用hang住
- 用户无法判断是否需要重试

### 2. 批量处理问题
**文件**: `src/stores/mail.js`

[fetchMailsFromServer](file://c:\Users\Administrator\Documents\Maillionaire\src\stores\mail.js#L150-L261) 一次性拉取所有邮件：
- 默认拉取 50 封邮件，但都在一个请求中
- 大邮件或附件多的邮件会导致超时
- 一旦失败，整个操作都失败

### 3. 日志不完善
- 缺少详细的进度日志
- 用户无法了解当前处理到哪一步
- 调试困难

### 4. 错误处理不完善
- 解析单个邮件失败会影响整批邮件
- 没有容错机制
- 连接清理不彻底

## 解决方案

### 1. 添加超时机制

**文件**: `electron/services/imap-main.js`

在 `fetchAndParseMails()` 中添加 60 秒超时：

```javascript
async fetchAndParseMails(uids) {
  return new Promise((resolve, reject) => {
    // ... 验证代码 ...
    
    console.log(`[IMAP] Fetching and parsing ${uids.length} mails...`);
    
    const mails = [];
    const fetch = this.connection.fetch(uids, {
      bodies: '',
      struct: true,
    });
    
    // 设置超时（60秒）
    const timeout = setTimeout(() => {
      console.error('[IMAP] Fetch timeout after 60s');
      fetch.removeAllListeners();
      reject(new Error('Mail fetch timeout after 60 seconds'));
    }, 60000);
    
    let processedCount = 0;
    
    // ... 处理逻辑 ...
    
    fetch.once('end', () => {
      clearTimeout(timeout);
      console.log(`[IMAP] Fetch completed, total ${mails.length} mails`);
      resolve(mails);
    });
  });
}
```

**关键点**：
- 60 秒后自动超时
- 清理所有事件监听器避免内存泄漏
- 返回清晰的超时错误信息

### 2. 批量分页拉取

**文件**: `src/stores/mail.js`

将邮件拉取改为分批处理：

```javascript
async function fetchMailsFromServer(folderName = 'INBOX', options = {}) {
  // ... 前置代码 ...
  
  const limit = options.limit || 50
  const fetchUids = uids.slice(-limit)
  
  console.log(`[Mail] Fetching ${fetchUids.length} mails (limited from ${uids.length})...`)

  // 批量获取并解析邮件（分批处理避免超时）
  const batchSize = 10 // 每批次10封
  const fetchedMails = []
  
  for (let i = 0; i < fetchUids.length; i += batchSize) {
    const batch = fetchUids.slice(i, i + batchSize)
    console.log(`[Mail] Fetching batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(fetchUids.length / batchSize)} (${batch.length} mails)...`)
    
    try {
      const batchMails = await window.electronAPI.fetchAndParseImapMails(batch)
      fetchedMails.push(...batchMails)
      console.log(`[Mail] Batch fetched: ${batchMails.length} mails, total: ${fetchedMails.length}/${fetchUids.length}`)
    } catch (error) {
      console.error(`[Mail] Batch fetch failed:`, error)
      // 继续处理下一批，不要因为一批失败而停止
      continue
    }
  }
  
  console.log(`[Mail] Fetched total ${fetchedMails.length} mails`)
  
  // ... 后续处理 ...
}
```

**优势**：
- 每批只拉取 10 封邮件，降低超时风险
- 单批失败不影响其他批次
- 提供详细的进度日志
- 用户可以看到实时进度

### 3. 增强日志输出

在关键步骤添加日志：

```javascript
console.log('[Mail] Connecting to IMAP...')
console.log('[Mail] Opening folder: ${folderName}')
console.log('[Mail] Searching mails...')
console.log('[Mail] Found ${uids.length} mails')
console.log('[Mail] Fetching ${fetchUids.length} mails (limited from ${uids.length})...')
console.log('[Mail] Disconnecting from IMAP...')
```

### 4. 改进错误处理

#### A. 单个邮件解析失败容错

```javascript
msg.on('body', async (stream, info) => {
  try {
    const parsed = await simpleParser(stream);
    // ... 正常处理 ...
  } catch (error) {
    console.error('[IMAP] Failed to parse mail:', error);
    // 解析失败也要继续处理，不影响其他邮件
    mailData.parsed = {
      from: '',
      to: '',
      subject: '(解析失败)',
      date: new Date(),
      text: error.message,
      html: '',
      textAsHtml: '',
      attachments: [],
    };
  }
});
```

#### B. 批次失败容错

```javascript
try {
  const batchMails = await window.electronAPI.fetchAndParseImapMails(batch)
  fetchedMails.push(...batchMails)
} catch (error) {
  console.error(`[Mail] Batch fetch failed:`, error)
  // 继续处理下一批
  continue
}
```

#### C. 连接清理优化

```javascript
catch (error) {
  console.error('[Mail] Failed to fetch mails:', error)
  
  // 确保断开连接
  if (window.electronAPI) {
    try {
      console.log('[Mail] Cleaning up: disconnecting...')
      await window.electronAPI.disconnectImap()
    } catch (e) {
      console.warn('[Mail] Disconnect error (ignored):', e.message)
    }
  }
  
  throw error
}
```

### 5. 进度计数器

```javascript
let processedCount = 0;

msg.once('end', () => {
  processedCount++;
  mails.push(mailData);
  console.log(`[IMAP] Processed ${processedCount}/${uids.length} mails`);
});
```

## 优化效果

### 优化前
```
问题：
- 拉取 50 封邮件时可能超时
- 一旦超时，整个操作失败
- 用户不知道进度
- 无法判断是卡住还是在处理

日志示例：
[Mail] Fetching mails from INBOX...
[Mail] Found 127 mails
（长时间无反应）
```

### 优化后
```
改进：
- 分批拉取，每批 10 封
- 60 秒超时保护
- 详细的进度日志
- 单批失败不影响其他批次

日志示例：
[Mail] Fetching mails from INBOX...
[Mail] Connecting to IMAP...
[Mail] Opening folder: INBOX
[Mail] Searching mails...
[Mail] Found 127 mails
[Mail] Fetching 50 mails (limited from 127)...
[Mail] Fetching batch 1/5 (10 mails)...
[IMAP] Fetching and parsing 10 mails...
[IMAP] Processed 1/10 mails
[IMAP] Processed 2/10 mails
...
[IMAP] Processed 10/10 mails
[IMAP] Fetch completed, total 10 mails
[Mail] Batch fetched: 10 mails, total: 10/50
[Mail] Fetching batch 2/5 (10 mails)...
...
[Mail] Fetched total 50 mails
[Mail] Disconnecting from IMAP...
```

## 性能对比

| 指标 | 优化前 | 优化后 |
|------|--------|--------|
| 超时保护 | ❌ 无 | ✅ 60秒 |
| 批量大小 | 50封/批 | 10封/批 |
| 失败恢复 | ❌ 全部失败 | ✅ 单批失败继续 |
| 进度反馈 | ❌ 无 | ✅ 实时显示 |
| 日志详细度 | ⚠️ 少 | ✅ 详细 |
| 容错能力 | ❌ 弱 | ✅ 强 |

## 测试场景

### 1. 正常场景 - 少量邮件

**步骤**：
1. 选择有少量邮件的账户（< 10 封）
2. 点击同步
3. 观察控制台日志

**期望结果**：
```
[Mail] Fetching batch 1/1 (5 mails)...
[IMAP] Processed 1/5 mails
...
[Mail] Batch fetched: 5 mails, total: 5/5
[Mail] Fetched total 5 mails
```

### 2. 正常场景 - 大量邮件

**步骤**：
1. 选择有大量邮件的账户（> 100 封）
2. 点击同步（默认拉取最新 50 封）
3. 观察批次处理

**期望结果**：
```
[Mail] Found 234 mails
[Mail] Fetching 50 mails (limited from 234)...
[Mail] Fetching batch 1/5 (10 mails)...
[Mail] Fetching batch 2/5 (10 mails)...
...
[Mail] Fetching batch 5/5 (10 mails)...
[Mail] Fetched total 50 mails
```

### 3. 异常场景 - 网络慢

**步骤**：
1. 模拟慢网络（限速或高延迟代理）
2. 点击同步
3. 等待超时

**期望结果**：
```
[IMAP] Fetch timeout after 60s
Error: Mail fetch timeout after 60 seconds
```

### 4. 异常场景 - 单个邮件解析失败

**步骤**：
1. 邮箱中有格式损坏的邮件
2. 点击同步
3. 观察是否继续处理其他邮件

**期望结果**：
```
[IMAP] Failed to parse mail: Error: ...
[IMAP] Processed 1/10 mails (subject: (解析失败))
[IMAP] Processed 2/10 mails (正常邮件)
...
```

### 5. 异常场景 - 批次失败

**步骤**：
1. 模拟中途网络断开
2. 点击同步
3. 观察是否继续下一批

**期望结果**：
```
[Mail] Fetching batch 2/5 (10 mails)...
[Mail] Batch fetch failed: Error: Connection lost
[Mail] Fetching batch 3/5 (10 mails)...
（继续处理）
```

## 用户体验改进

### 1. 更快的反馈
- 每批 10 封，用户可以更快看到第一批结果
- 不用等待全部 50 封都拉取完

### 2. 更可靠
- 批次失败不影响整体
- 超时保护避免无限等待
- 自动重试机制（分批本身就是重试）

### 3. 更透明
- 详细日志让用户知道进度
- 可以判断是在处理还是卡住
- 便于问题排查

## 后续优化建议

### 1. 自适应批量大小
```javascript
// 根据邮件大小动态调整批量大小
const avgSize = estimateAverageMailSize(uids)
const batchSize = avgSize > 1024 * 1024 ? 5 : 10 // 大邮件减少批量
```

### 2. 并发拉取
```javascript
// 同时拉取多个批次（需要注意并发控制）
const promises = []
for (let i = 0; i < batches.length && i < 3; i++) {
  promises.push(fetchBatch(batches[i]))
}
await Promise.all(promises)
```

### 3. 断点续传
```javascript
// 记录已拉取的 UID，下次从断点继续
const lastFetchedUid = localStorage.getItem('lastFetchedUid')
const newUids = uids.filter(uid => uid > lastFetchedUid)
```

### 4. 进度条显示
```javascript
// 在 UI 上显示进度条
const progress = (fetchedCount / totalCount) * 100
message.loading(`正在拉取邮件... ${progress.toFixed(0)}%`)
```

### 5. 智能限流
```javascript
// 根据服务器响应速度动态调整请求间隔
const delay = Math.max(100, avgResponseTime * 0.1)
await sleep(delay)
```

## 相关文件

- `electron/services/imap-main.js` - IMAP 服务主进程实现
- `src/stores/mail.js` - 邮件状态管理
- `src/views/Main.vue` - 主界面同步逻辑

## 参考资料

- [Node.js IMAP 库文档](https://github.com/mscdex/node-imap)
- [mailparser 文档](https://nodemailer.com/extras/mailparser/)
- [Promise 超时处理最佳实践](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)
